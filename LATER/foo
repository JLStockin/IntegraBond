
		##################################################################################
		#
		# State Machine -- this is the entry point for a Transaction
		#

		state_machine :machine_state, :initial => :s_bootstrap do

			#
			# Events -- someone wants to publish an offer to sell, or make an offer to buy 
			#
			event :artifact_offer do
				transition :s_bootstrap => :s_offered
			end

			event :artifact_published_offer do
				transition :s_bootstrap => :s_published
			end

			#
			# Callbacks
			#
			before_transition :s_bootstrap => [:s_offered, :s_published] do |goal, transition|
				transaction = goal.transaction
				new_goal = transaction.create_goal_accept()
puts p transition
				new_goal.expires_at(DateTime.now.advance(transaction.read_param(:active_artifact)
				true
			end

			#########################################################################
			#
			#                        States and events
			#
			#########################################################################
			#
			around_transition do |transaction, transition, block|
				puts ">>>> before: #{transition}"
				block.call
				puts ">>>> after: #{transition}"
			end

			#
			# Specific callbacks
			#

			# This creates a listing
			before_transition :s_listing, :to => :s_accepting do |transition, transaction|
				return false unless party(role_of_origin()).sufficient_funds?
				party(role_of_origin).bond()	
				true
			end

			# Other party accepts, bonds
			before_transition :s_accepting, :to => :s_confirming do |transaction, transition|
				return false unless party(other_role()).sufficient_funds?()
				limit_counter_offer(true)
				party(other_role()).bond()
				true
			end

			# Happens on :counter (offer).  Only one party has antied up, so no penalty for
			# countering item, terms, etc.  TODO: figure who made the counter.
			before_transition :s_accepting, :to => :s_accepting do |transaction, transition|
				role = requesting_role()
				party(role_of_origin()).release_bond()
				originate(role)
				party(role).bond()
				limit_counter_offer(false)
				true
			end

			# This happens on :counter.  Both parties have antied up, so only reschedule
			# and cancel are allowed.
			before_transition :s_confirming, :to => :s_confirming do |transaction, transition|
				originate(other_role())
				limit_counter_offer(true)
				confirm_appointment(false)
				true
			end

			# Happens on :accept or :expire
			before_transaction :s_confirming, :to => :s_waiting_2_meet do |transition, transaction|
				confirm_appointment(true)
			end

			before_transaction :s_waiting_2_meet, :to => :s_confirming \
				do |transition, transaction|
				confirm_appointment(false)
			end

			#
			# The :s_requesting_* states all require that the prior state get cached,
			# and that transaction_params[:requesting_role] is set.
			#
			# The outcome hinges on the other party's decision and can result in the
			# transaction either returning to its prior state, or advancing to another
			# one, typically :s_accepting or :s_cancelled.
			#
			before_transition :s_waiting_no_cancel, :to => :s_requesting_cancel \
					do |transaction, transition|
				cache_state(:s_waiting_no_cancel)
				true
			end

			before_transition :s_waiting_no_cancel_or_counter, :to => \
				[:s_requesting_cancel, :s_requesting_counter] do |transaction, transition| 
				cache_state(:s_waiting_no_cancel_or_counter)
				true
			end

			after_transition :s_requesting_cancel, :to => s_cancelled do |transaction, transition| 
				set_requesting_role(nil)
				set_fault(:buyer, false)
				set_fault(:seller, false)
			end

			# Someone may request a meeting time change in order to get out
			# of a transaction well into it.  Make them at fault, so if they don't carry through,
			# they'll lose their deposit.
			#
			before_transition [:s_requesting_counter, :to => s_confirming] \
					do |transaction, transition| 
				confirm_appointment(false)
				requester = requesting_role() 
				originate(requester)
				fault = (requester.to_s + "_fault").to_sym
				write_transaction_param(fault, true)
			end

			# Someone (or system) has just confirmed that the other party arrived
			# (:ack_arrived).  Notify other party and proceed to next step.
			before_transition :s_meeting, :to => :s_inspecting do |transaction, transition| 
				meet = read_transaction_param[:goals][:meet]
				late = read_transaction_param[:goals][:late]
				Transaction.roles.each do |role|
					if !evidence?(	:subject => party(role).user, \
									:object => party(opposite_role(role)).user, \
									:event => :ack_arrived, \
									:location => get_locaton(), \
									:between => [ meet, meet + late ] \
								 ) then
						return false
					end
				end
				true
			end

			# Someone has just claimed that they have arrived (:assert_arrived).
			# Notify other party. 
			after_transition :s_meeting, :to => :s_meeting do
				# TODO: implement
				#evidence = read_transaction_param(:cached_evidence)
				#raise "no evidence cached to be found." \
				#	unless !evidence.nil?
				#raise "evidence is not of expected type.  Did you mean to :assert_arrived" \
				#	+ "instead of :ack_arrived?" \
				#	unless evidence[:subject] == evidence[:object] \
				#	and evidence[:event] == :assert_arrived
				# evidence.message(evidence[:subject].role.user)
				true
			end

			#
			# Buyer can't automatically make a counter offer at this point.  However,
			# she may say there's a problem with the goods and cancel.
			#
			after_transition :s_inspecting, :to => :s_requesting_counter \
					do |transaction, transition|
				write_transaction_param(:limit_counter_offer, true)
			end

			#
			# Buyer has inspected goods and nobody is at fault here.
			#
			after_transition :s_inspecting, :to => :s_cancelled do |transaction, transition| 
				# Declare draw
				party(:seller).release_bond()
				party(:buyer).release_bond()
			end

			#
			# Buyer didn't pay and is at fault 
			#
			after_transition :s_paying, :to => :s_cancelled do |transaction, transition| 
				transaction.party(:buyer).award_bond(party(:seller))
			end

			#
			# The grand finale.  Settle up.  
			#
			before_transition :s_closing, :to => :s_completed do |transaction, transition|
				
				# Declare draw
				transaction.party(:seller).release_bond()
				transaction.party(:buyer).release_bond()
			end

			#########################################################################
			#
			#                        States and events
			#
			#########################################################################

			# :ignomy means this transaction doesn't even get recorded
			state :s_listing do #1
				transition :to => :s_ignomy, :on => :delete_transaction
				transition :to => :s_accepting, :on => :bond, \
					:if => transaction.sufficient_funds?(transaction.role_of_origin)
			end

			state :s_accepting  do |transaction, transition| #2
				transition :to => :s_disputing, :on => :dispute
				transition :to => :same, :on => :counter
				transition :to => :s_bonding, :on => [:expire, :cancel]
				transition :to => :s_confirming_appt, :on => :bond, \
					:if => sufficient_funds?( other_role() ) 
			end

			state :s_confirming_appt do #3
				transition :to => :s_disputing, :on => :dispute
				transition :to => :same, :on => :counter
				transition :to => :s_waiting2meet, :on => [:accept, :expire] 
				transition :to => :s_cancelled, :on => :cancel 
			end

			state :s_waiting2meet do #4
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_confirming_appt, :on => :counter
				transition :to => :s_waiting_no_cancel, :on => :expire
				transition :to => :s_cancelled, :on => :cancel
			end

			# These two states advance to the next via expire 
			state :s_waiting_no_cancel do #5
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_confirming_appt, :on => :counter
				transition :to => :s_waiting_no_cancel_or_counter, :on => :expire
				transition :to => :s_requesting_cancel, :on => :cancel
			end

			state :s_waiting_no_cancel_or_counter do  #6
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_meeting, :on => :expire
				transition :to => :s_requesting_counter, :on => :counter
				transition :to => :s_requesting_cancel, :on => :cancel
			end

			state :s_meeting do #7
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_cancelling, :on => :expire
				transition :to => :s_inspecting, :on => :ack_arrive
				transition :to => :same, :on => :assert_arrive
			end

			state :s_cancel do #8
				transition :to => :s_disputing, :on => :dispute
			end

			state :s_inspecting do #9
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_paying, :on => :expire
				transition :to => :s_paying, :on => :ack_goods_ok
				transition :to => :s_requesting_counter, :on => :counter
				transition :to => :s_cancelled, :on => :cancel
			end

			state :s_paying do #10
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_cancelled, :on => :expire # with fault!
				transition :to => :s_requesting_counter, :on => :counter
				transition :to => :s_requesting_cancel, :on => :cancel
			end

			state :s_closing do #11
				transition :to => :s_disputing, :on => :dispute
				transition :to => :s_completed, :on => :expire
				transition :to => :s_requesting_counter, :on => :counter # with fault!
				transition :to => :s_requesting_cancel, :on => :cancel # with fault!
			end

			state :s_completed do #12
				transition :to => :s_disputing, :on => :dispute
			end

			state :s_requesting_cancel do #13
				transition :to => :s_cancelled, :on => :approve
				transition :to => :s_deciding, :on => :deny
				transition :to => :s_pop, :on => :expire
			end

			state :s_requesting_counter do #14
				transition :to => :s_confirming_appt, :on => :approve
				transition :to => :s_deciding, :on => :deny
				transition :to => :s_pop, :on => :expire
			end

			state :s_deciding do #15
				# TODO -- fix
				transition :to => :s_cancelled, :on => :insist # => with !penalty!
				transition :to => :s_pop, :on => [:resume, :expire] #
			end

			state :s_disputing do #16
				# TODO -- fix
				# Operator discretion: 
				# transition :to => # TBD: :s_pop, :s_cancelled, :s_completed
			end

			state :ignomy do

			end

		end # StateMachine
